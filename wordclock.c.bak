#include <Time.h>
#include <SPI.h>
#include <DCF77.h>
#include <Logging.h>
#include <LPD8806.h>


// PINS
const byte PIN_DCF77 = 2;
const byte PIN_LDR = A0;
const byte PIN_LED = 13;

// INTERRUPTS
const byte INTERRUPT_DCF77 = 0;

// LANGUAGES
const byte LANGUAGE_DE_DE = 0;
const byte LANGUAGE_DE_SW = 1;
const byte LANGUAGE_EN = 2;

// CACHE
const byte LDR_NUMBER_OF_LEVELS = 8;
const byte LDR_CACHE_SIZE = 32;
byte ldrCache[LDR_CACHE_SIZE];
byte ldrDensityLevel = 0;

// DCF77
time_t time;
DCF77 dcf77 = DCF77(PIN_DCF77, INTERRUPT_DCF77);
time_t prevDisplay = 0;

// LEDs
const byte LED_NUMBER_OF_LEDS = 126;
LPD8806 ledStrip = LPD8806(LED_NUMBER_OF_LEDS);

word matrix[11];

#define DE_X_ESIST       matrix[0] |= 0b1101110000000000
#define DE_X_VOR         matrix[3] |= 0b1110000000000000
#define DE_X_NACH        matrix[3] |= 0b0000000111100000
#define DE_X_UHR         matrix[9] |= 0b0000000011100000

#define DE_M_FUENF       matrix[0] |= 0b0000000111100000
#define DE_M_ZEHN        matrix[1] |= 0b1111000000000000
#define DE_M_VIERTEL     matrix[2] |= 0b0000111111100000
#define DE_M_ZWANZIG     matrix[1] |= 0b0000111111100000
#define DE_M_HALB        matrix[4] |= 0b1111000000000000
#define DE_M_DREIVIERTEL matrix[2] |= 0b1111111111100000

#define DE_H_EIN         matrix[5] |= 0b1110000000000000
#define DE_H_EINS        matrix[5] |= 0b1001000000000000
#define DE_H_ZWEI        matrix[5] |= 0b0000000111100000
#define DE_H_DREI        matrix[6] |= 0b1111000000000000
#define DE_H_VIER        matrix[6] |= 0b0000000111100000
#define DE_H_FUENF       matrix[4] |= 0b0000000111100000
#define DE_H_SECHS       matrix[7] |= 0b1111100000000000
#define DE_H_SIEBEN      matrix[8] |= 0b1111110000000000
#define DE_H_ACHT        matrix[7] |= 0b0000000111100000
#define DE_H_NEUN        matrix[9] |= 0b0001111000000000
#define DE_H_ZEHN        matrix[9] |= 0b1111000000000000
#define DE_H_ELF         matrix[4] |= 0b0000011100000000
#define DE_H_ZWOELF      matrix[8] |= 0b0000001111100000

#define DE_M_1           matrix[10] |= 0b1111000000000000
#define DE_M_2           matrix[10] |= 0b0000111100000000
#define DE_M_3           matrix[10] |= 0b0000000011110000
#define DE_M_4           matrix[10] |= 0b0000000000001111

// Set DEBUG mode on/off
const LOG_LEVEL = LOG_LEVEL_DEBUG;


/// <summary>
/// Initializes the DCF77, LDR and LEDs.
/// </summary>
void setup()
{
  // Initialize logging
  Log.Init(LOG_LEVEL, 9600);

  // Define INPUT and OUTPUT PINS  
  pinMode(PIN_DCF77, INPUT);
  pinMode(PIN_LDR, INPUT);
  pinMode(PIN_LED, OUTPUT);

  // Activate internal Pull-Up for PIN_DCF77
  digitalWrite(PIN_DCF77, HIGH);

  // Activate cache for LDR
  initializeCache();

  // Start up the LED strip
  ledStrip.begin();
  // Update the strip, to start they are all 'off'
  ledStrip.show();

  // Activate DCF77 sensor
  dcf77.Start();
  setSyncInterval(30);
  setSyncProvider(getDCF77Time);

  // Render a fancy matrix effect until we receiv the time
  Log.Debug("Waiting for time from DCF77..."CR)
  Log.Debug("It will take at least 2 minutes until a first update can be processed."CR);
  while(timeStatus()== timeNotSet) { 
    // wait until the time is set by the sync provider     
    Log.Debug(".");
    delay(2000);
  }
  Log.Debug(CR);
}

void loop()
{
		/*
  if( now() != prevDisplay) //update the display only if the time has changed
  {
    prevDisplay = now();
    digitalClockDisplay(); 
    // LDR
    //
    //handleLDR();
    // LEDs
    renderBuffer(); 
  }
  * */
  testHandleLDR();
}



// -------------------------
// DCF-77
// -------------------------

unsigned long getDCF77Time()
{ 
  time_t dcf77Time = dcf77.getTime();
  if (dcf77Time != 0)
    Log.Debug("Time is updated!");
  return dcf77Time;
}

void digitalClockDisplay(){
  // digital clock display of the time
  Log.Debug(CR);
  printDigits(hour());
  printDigits(minute());
  printDigits(second());
  Log.Debug(" %d %d %d"CR, day(), month(), year());
}

void printDigits(int digits){
  // utility function for digital clock display: prints preceding colon and leading 0
  Log.Debug(":");
  if(digits < 10)
    Log.Debug('0');
  Log.Debug(digits);
}

// -------------------------
// LED
// -------------------------

void renderBuffer()
{
  clearBuffer();
  setTime(LANGUAGE_DE_SW, hour(), minute());
  for (byte i = 0; i < 11; i++)
    render(i, matrix[i]);
  ledStrip.show();
}

void render(byte rowIdx, word data)
{
  // Row 10 contains special bitmasks for the edge LEDs
  if (rowIdx == 10) 
  {  
    if (data & 0b1111000000000000)
      ledStrip.setPixelColor(123, 64, 0, 64);
    if (data & 0b0000111100000000)
      ledStrip.setPixelColor(121, 64, 0, 64);
    if (data & 0b0000000011110000)
      ledStrip.setPixelColor(119, 64, 0, 64);
    if (data & 0b0000000000001111)
      ledStrip.setPixelColor(125, 64, 0, 64);
    return;
  }

  // Unfortunately I failed when building the initial layout, which is why the first two rows consist of 11 LEDs
  // while all other rows consist of 12 LEDs. This must be fixed here, otherwise the positions of LEDs to activate
  // cannot be determined correctly.
  byte offset = 2;
  if (rowIdx < 2)
    offset = 0;

  byte ledIdx = 0;
  byte idx = 0;
  // Even or odd row? This is important for the determination of LEDs to activate, since even rows are treated from
  // left to right whereas odd rows are treated right to left.
  if (rowIdx % 2 == 0) 
  {
    // Hop over our bitmask from MSB -> LSB
    for (word bitMask = 32768; bitMask > 8; bitMask >>= 1)  
    {
      word value = data & bitMask;
      ledIdx = rowIdx * 12 - offset + idx++;
      if (value)
        ledStrip.setPixelColor(ledIdx, 16, 0, 16);
      else
        ledStrip.setPixelColor(ledIdx, 0, 0, 0);
    }
  }
  else
  {
    // Hop over our bitmask from LSB -> MSB
    for (word bitMask = 16; bitMask > 0 && bitMask <= 32768; bitMask <<= 1) 
    {
      word value = data & bitMask;
      ledIdx = rowIdx * 12 - offset + idx++;
      if (value)
        ledStrip.setPixelColor(ledIdx, 16, 0, 16);
      else
        ledStrip.setPixelColor(ledIdx, 0, 0, 0);
    }
  }
}

void clearBuffer()
{
  // The matrix contains 11 rows (0 to 10)
  for (byte i = 0; i < 11; i++)
    matrix[i] = 0;
}

void renderMatrixEffect() 
{
  for (byte i = 0; i < 11; i++) {

  }
}


/**
 * Setzt die Wortminuten, je nach hours/minutes.
 */
void setTime(byte language, byte hours, byte minutes)
{
  boolean isFullHour = (minutes % 5 == 0);
  byte hourCorrection = (minutes >= 25);
  setHours(language, hours, hourCorrection, isFullHour);
  setMinutes(language, minutes);
  setCorners(minutes);
}

/**
 * Setzt die Stunden, je nach hours. 'glatt' bedeutet,
 * es ist genau diese Stunde und wir muessen 'UHR'
 * dazuschreiben und EIN statt EINS, falls es 1 ist.
 * (Zumindest im Deutschen)
 */
void setHours(byte language, byte hours, byte hourCorrection, boolean isFullHour)
{
  if (isFullHour)
    DE_X_UHR;
    
  hours = hours + hourCorrection;

  switch (hours) {
  case 0:
  case 12:
  case 24:
    DE_H_ZWOELF;
    break;
  case 1:
  case 13:
    if (isFullHour)
      DE_H_EIN;
    else
      DE_H_EINS;
    break;
  case 2:
  case 14:
    DE_H_ZWEI;
    break;
  case 3:
  case 15:
    DE_H_DREI;
    break;
  case 4:
  case 16:
    DE_H_VIER;
    break;
  case 5:
  case 17:
    DE_H_FUENF;
    break;
  case 6:
  case 18:
    DE_H_SECHS;
    break;
  case 7:
  case 19:
    DE_H_SIEBEN;
    break;
  case 8:
  case 20:
    DE_H_ACHT;
    break;
  case 9:
  case 21:
    DE_H_NEUN;
    break;
  case 10:
  case 22:
    DE_H_ZEHN;
    break;
  case 11:
  case 23:
    DE_H_ELF;
    break;
  }
}

void setMinutes(byte language, byte minutes)
{
  // Common German
  switch (language) {
  case LANGUAGE_DE_DE:
    DE_X_ESIST;

    switch (minutes / 5) {
    case 1:
      // 5 nach
      DE_H_FUENF;
      DE_X_NACH;
      break;
    case 2:
      // 10 nach
      DE_H_ZEHN;
      DE_X_NACH;
      break;
    case 3:
      // viertel nach
      DE_M_VIERTEL;
      DE_X_NACH;
      break;
    case 4:
      // 20 nach
      DE_M_ZWANZIG;
      DE_X_NACH;
      break;
    case 5:
      // 5 vor halb
      DE_M_FUENF;
      DE_X_VOR;
      DE_M_HALB;
      break;
    case 6:
      // halb
      DE_M_HALB;
      break;
    case 7:
      // 5 nach halb
      DE_M_FUENF;
      DE_X_NACH;
      DE_M_HALB;
      break;
    case 8:
      // 20 vor
      DE_M_ZWANZIG;
      DE_X_VOR;
      break;
    case 9:
      // viertel vor
      DE_M_VIERTEL;
      DE_X_VOR;
      break;
    case 10:
      // 10 vor
      DE_M_ZEHN;
      DE_X_VOR;
      break;
    case 11:
      // 5 vor
      DE_M_FUENF;
      DE_X_VOR;
      break;
    default:
      break;
    }

    break;
    //
    // Deutsch: Schwaebisch
    //
  case LANGUAGE_DE_SW:
    DE_X_ESIST;
    switch (minutes / 5) {
    case 1:
      // 5 nach
      DE_M_FUENF;
      DE_X_NACH;
      break;
    case 2:
      // 10 nach
      DE_M_ZEHN;
      DE_X_NACH;
      break;
    case 3:
      // viertel
      DE_M_VIERTEL;
      break;
    case 4:
      // 20 nach
      DE_M_ZWANZIG;
      DE_X_NACH;
      break;
    case 5:
      // 5 vor halb
      DE_M_FUENF;
      DE_X_VOR;
      DE_M_HALB;
      break;
    case 6:
      // halb
      DE_M_HALB;
      break;
    case 7:
      // 5 nach halb
      DE_M_FUENF;
      DE_X_NACH;
      DE_M_HALB;
      break;
    case 8:
      // 20 vor
      DE_M_ZWANZIG;
      DE_X_VOR;
      break;
    case 9:
      // dreiviertel
      DE_M_DREIVIERTEL;
      break;
    case 10:
      // 10 vor
      DE_M_ZEHN;
      DE_X_VOR;
      break;
    case 11:
      // 5 vor
      DE_M_FUENF;
      DE_X_VOR;
      break;
    default:
      break;
    }
    break;
  }
}

/// <summary>
/// Sets the corner LEDs indicating the minutes.
/// </summary>
void setCorners(byte minutes) 
{
  switch (minutes % 5) {
  case 0:
    break;
  case 1:
    DE_M_1;
    break;
  case 2:
    DE_M_1;
    DE_M_2;
    break;
  case 3:
    DE_M_1;
    DE_M_2;
    DE_M_3;
    break;
  case 4:
    DE_M_1;
    DE_M_2;
    DE_M_3;
    DE_M_4;
    break;
  default:
    break;
  }
}


// -------------------------
// LDR
// -------------------------

void testHandleLDR()
{
  Log.Debug(CR);
  // Read the value from the LDR
  byte sensorValue = map((int)random(0, 1023), 0, 1024, 0, LDR_NUMBER_OF_LEVELS);
  Log.Debug("Sensor value: %d"CR, sensorValue)
  // delay(1000);

  // Push it to the stack
  addToCache(sensorValue);
  // delay(1000);

  Log.Debug("Cache content: ");
  for (word i = 0; i < LDR_CACHE_SIZE; i++)
    Log.Debug(" %d", ldrCache[i]);
  Log.Debug(CR);

  // Get the average density
  byte averageDensityValue = getAverageDensityValue();
  Log.Debug("Average density value: %d"CR, averageDensityValue);
  // delay(1000);
}

void handleLDR()
{
  // Read the value from the LDR
  int sensorValue = analogRead(PIN_DCF77);
  byte mappedSensorValue = map(sensorValue, 0, 1023, 0, LDR_NUMBER_OF_LEVELS);
  // Push it to the stack
  addToCache(mappedSensorValue);
  // Get the average density
  ldrDensityLevel = getAverageDensityValue();
}

void initializeCache()
{
  byte defaultValue = LDR_NUMBER_OF_LEVELS / 2;
  for (byte i = 0; i < LDR_CACHE_SIZE; i++)
    ldrCache[i] = defaultValue;
}

void addToCache(byte value)
{
  for(byte i = LDR_CACHE_SIZE - 1; i >= 0; i--)
  {
    if (ldrCache[i] < 0)
    {
      if (i > 0 && ldrCache[i - 1] < 0)
        continue;
      ldrCache[i] = value;
      return;
    }
    for (byte j = 1; j < LDR_CACHE_SIZE; j++)
      ldrCache[j - 1] = ldrCache[j];
    ldrCache[LDR_CACHE_SIZE - 1] = value;
    return;
  }
}

byte getAverageDensityValue()
{
  unsigned long sum = 0;
  for (byte i = 0; i < LDR_CACHE_SIZE; i++)
  {
    if (ldrCache[i] < 0)
      continue;
    sum += ldrCache[i];
  }
  return (byte) (sum / LDR_CACHE_SIZE);
}


